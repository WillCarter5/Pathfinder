# General Info

## About this project

I made this project for my Data Structures and Algorithm's mini project. Afterwards, I learned and implemented `pip` and `venv`. I also made Wikispeedia as part of this project, which is also on my GitHub.

## Setup

To set up the project using `pip` + `venv`:

1. **Create a virtual environment**

```bash
python -m venv .venv
````

2. **Activate the virtual environment**

* macOS / Linux

```bash
source .venv/bin/activate
```

* Windows

```powershell
.venv\Scripts\activate
```

3. **Install dependencies**

```bash
pip install geopandas networkx matplotlib shapely
```

4. **Freeze dependencies for reproducibility**

```bash
pip freeze > requirements.txt
```
---

## Makefile

* `make demo`: demos pathfinder's ability to correctly find the shortest path between Alumni Hall and Hesburgh Library. After running the program, a map will appear in the `out` directory.
* `make test`: runs the test script for pathfinder (pathfinder_test.py)

---

# Usage Instructions

## Running the Command

- The command takes the form: `./pathfinder.py [-d DATA_FILE] [-o OUTPUT_FILE] [-m MODE] [-s START] [-e END]`.
- `mode` supports the string `coord` or a valid path to a Place of Interest (POI) datafile
  - `man`:      `./pathfinder.py [-d DATA_FILE] [-o OUTPUT_FILE] [-m PATH_TO_POI_FILE] [-s NAMED_LOC_START] [-e NAMED_LOC_END]`
    - Supports the entry of named places of interest.
    - The program expects tab delimited data with place name first, then latitude, then longitude.
  - `coord`:    `./pathfinder.py [-d DATA_FILE] [-o OUTPUT_FILE] -m coord [-s START_COORD] [-e END_COORD]`
    - Supports the entry of coordinate pairs (with latitude first).
  
## Files

Two datasets are available for use. 
- `nd_paths.geojson` covers main campus
- `nd_paths_big.geojson` covers main campus as well as St. Mary's College and Holy Cross College.

---

# Explanation

## Obtaining Data

Data was obtained using [Overpass Turbo](https://overpass-turbo.eu/). Datasets were obtained using [OpenStreetMaps](openstreetmap.org) and [Overpass Turbo](https://overpass-turbo.eu/#). Below is the query used to obtain each dataset:
```overpassql
[out:json][timeout:60];

// Bounding box
(
  // All named buildings: nodes, ways, relations
  way["highway"]({{bbox}});
);

// Include all nodes of the ways/relations
(._;>;);

// Output building centroids + node coordinates
out center;   // "center" gives centroid for ways/relations
```
In each dataset, {{bbox}} is substituted with the actual coordinates of the bounding box.
* `nd_paths.geojson`: 41.69265511929181, -86.24980178703196, 41.70841976683991,  -86.22533600588493
* `nd_paths_big.geojson`: 41.693552398067204, -86.26250872268491, 41.71220014428248,-86.22569592126408

## Data Input & Graph Creation

The data is stored in .geojson files and read into a dataframe using geopandas. To facilitate the creation of complex graphs, I used Python's Networkx package.

## Pathfinding with Djikstra's Algorithm

Once the graph is created, Djikstra's Algorithm is easy to implement. Dijkstra’s algorithm finds the shortest path from a starting node to all other nodes in a weighted graph with non-negative edge costs. It uses a priority queue to repeatedly select the currently closest unvisited node (according to Haversine distance), then updates the distances to its neighbors. Each update improves the best-known path until all reachable nodes have their minimum distance determined. The result is the shortest path tree and the shortest distance to any target node. The algorithm returns a path length in meters and the nodes that compose the path.

## Output

The program outputs the approximate distance in meters and stores the mapped shortest path in `[OUTPUT_FILE]` (preferably a .png).

## Testing

My test script tests my functions using an arbitrary, simpler, and significantly smaller data set. Testing on a real-world data set is outside the scope of this project and would require the handling of numerous edge cases. Through my own testing and demonstration, I have confirmed the function of the pathfinder program to a satisfactory degree. Furthermore, I have compared paths generated by the algorithm to the same path from Google maps. Additionally, I also manually measured the returned shortest path's distance between Alumni Hall and Hesburgh Library to be approximately 571 m, which is within 4 meters of the program's returned path length.

# Timing Analysis
Note: the command syntax has changed since this timing analysis.
```sh
➜ time ./pathfinder/pathfinder.py pathfinder/paths.geojson out.png man "Alumni" "Hesburgh" 
Start: (-86.2391309, 41.6999199) End: (-86.2341255, 41.7021925)
Length: 567.709328589976

real    0m7.980s
user    0m7.203s
sys     0m0.767s
➜ time ./pathfinder/pathfinder.py pathfinder/paths_big.geojson out.png man "Alumni" "Hesburgh" 
Start: (-86.2391309, 41.6999199) End: (-86.2341255, 41.7021925)
Length: 567.5976462045372

real    0m12.088s
user    0m11.171s
sys     0m0.904s
```
Dijkstra's algorithm is fairly quick. Most of the entire program's execution time is spent on matplotlib plot generation. When plot creation is disabled (commented out), the pathfinder program (with the larger data set) runs for approximately 2.381 seconds. 
```sh
➜ time ./pathfinder/pathfinder.py pathfinder/paths_big.geojson out.png man "Alumni" "Hesburgh" 
Start: (-86.2391309, 41.6999199) End: (-86.2341255, 41.7021925)
Length: 567.5976462045372

real    0m2.381s
user    0m1.817s
sys     0m0.563s
```
The program, expectedly, is slower for the larger data set (by approximately 4 seconds). Djikstra's algorithm has a runtime of O((V+E)logV), so this decrease in speed is consistent with the time complexity. Furthermore, the other elements of the program (file reading, graph generation, plot creation) are expected to decrease in speed as the data size increases.  
